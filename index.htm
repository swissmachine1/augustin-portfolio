<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Augustin Romaneschi | Tactical Command</title>

    <!-- Social Metadata -->
    <meta property="og:title" content="Augustin Romaneschi">
    <meta property="og:description"
        content="A tactical 3D command center for Augustin Romaneschi's portfolio.">
    

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Augustin Romaneschi | Tactical Command">
    <meta name="twitter:description"
        content="A tactical 3D command center for Augustin Romaneschi's portfolio..">
    <meta name="twitter:image" content="./augustin.jpeg">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Share Tech Mono', monospace;
            color: #0f0;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #canvas-container canvas {
            display: block;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            /* Flex layout removed, we position absolute elements now */
        }

        .hud-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            border: 1px solid #0f0;
            background: rgba(0, 17, 0, 0.9);
            padding: 15px;
            backdrop-filter: blur(2px);
            max-width: 300px;
        }

        .resource-row {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 14px;
            color: #0f0;
        }

        .resource-val {
            color: #fff;
            font-weight: bold;
        }

        h1 {
            margin: 0 0 5px 0;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px #0f0;
            color: #0f0;
        }

        .panel-label {
            position: absolute;
            top: -22px;
            right: 0;
            font-size: 12px;
            background: #000;
            padding: 2px 5px;
            border: 1px solid #0f0;
            border-bottom: none;
            color: #0f0;
        }

        /* Controls Bar */
        #controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0, 17, 0, 0.9);
            padding: 15px 20px;
            border: 2px solid #0f0;
            z-index: 20;
            min-width: 400px;
            display: block;
            /* Toggled via JS */
            pointer-events: auto;
        }

        .key {
            display: inline-block;
            border: 1px solid #0f0;
            padding: 2px 6px;
            margin: 0 2px;
            border-radius: 2px;
            font-size: 12px;
            background: #002200;
            color: #fff;
        }

        #construction-panel {
            display: none;
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            pointer-events: auto;
        }

        .build-card {
            background: rgba(0, 17, 0, 0.9);
            border: 2px solid #0f0;
            padding: 10px;
            width: 120px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .build-card:hover {
            background: rgba(0, 34, 0, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        .build-card.selected {
            border-color: #ffff00;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
        }

        .build-card.disabled {
            opacity: 0.5;
            filter: grayscale(1);
            cursor: not-allowed;
            border-color: #444;
        }

        .card-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .card-title {
            font-size: 12px;
            color: #0f0;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .card-cost {
            font-size: 10px;
            color: #ffff00;
        }

        /* Audio Control */
        #audio-toggle {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 40px;
            height: 40px;
            background: rgba(0, 17, 0, 0.9);
            border: 2px solid #0f0;
            color: #0f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            z-index: 25;
            transition: all 0.3s ease;
        }

        #audio-toggle:hover {
            background: rgba(0, 34, 0, 0.9);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        #audio-toggle.muted {
            color: #ff0000;
            border-color: #ff0000;
        }

        .audio-label {
            position: absolute;
            top: -22px;
            left: 0;
            right: 0;
            font-size: 10px;
            background: #000;
            padding: 2px 5px;
            border: 1px solid #0f0;
            border-bottom: none;
            color: #0f0;
            text-align: center;
            white-space: nowrap;
        }

        #audio-toggle.muted .audio-label {
            color: #ff0000;
            border-color: #ff0000;
        }

        .audio-credits {
            position: absolute;
            top: 50px;
            right: 0;
            width: 200px;
            background: rgba(0, 17, 0, 0.9);
            border: 1px solid #0f0;
            padding: 10px;
            font-size: 10px;
            color: #0f0;
            display: none;
            text-align: right;
            z-index: 30;
            pointer-events: auto;
        }

        #audio-toggle:hover .audio-credits {
            display: block;
        }

        .audio-credits a {
            color: #fff;
            text-decoration: none;
            border-bottom: 1px dotted #fff;
        }

        .sub-text {
            font-size: 12px;
            opacity: 0.9;
            color: #8f8;
            margin: 0 5px;
        }

        /* Mini Map */
        #minimap-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 200px;
            height: 200px;
            background: rgba(0, 17, 0, 0.9);
            border: 2px solid #0f0;
            z-index: 20;
            display: block;
            /* Toggled via JS */
            pointer-events: auto;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        /* Modals */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            background: #001100;
            border: 2px solid #0f0;
            padding: 30px;
            color: #fff;
            z-index: 100;
            pointer-events: auto;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
            scrollbar-width: thin;
            scrollbar-color: #0f0 #001100;
        }

        .modal::-webkit-scrollbar {
            width: 8px;
        }

        .modal::-webkit-scrollbar-track {
            background: #001100;
        }

        .modal::-webkit-scrollbar-thumb {
            background-color: #0f0;
            border-radius: 4px;
        }

        .modal.active {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .modal h2 {
            color: #0f0;
            border-bottom: 1px solid #0f0;
            padding-bottom: 10px;
            margin-top: 0;
            text-transform: uppercase;
        }

        .modal p {
            line-height: 1.6;
            color: #cfc;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #0f0;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
        }

        .close-btn:hover {
            color: #fff;
        }

        /* Scanlines */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 20;
            opacity: 0.3;
        }

        /* Mission Briefing */
        #mission-briefing {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 380px;
            background: linear-gradient(135deg, rgba(0, 17, 0, 0.95) 0%, rgba(0, 34, 0, 0.9) 100%);
            border: 2px solid #0f0;
            padding: 0;
            z-index: 50;
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.3), inset 0 0 20px rgba(0, 255, 0, 0.1);
            font-family: 'Share Tech Mono', monospace;
        }

        #mission-briefing.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: auto;
        }

        #game-over h1 {
            font-size: 60px;
            color: #f00;
            text-shadow: 0 0 20px #f00;
            margin-bottom: 20px;
        }

        #game-over button {
            background: #000;
            color: #f00;
            border: 2px solid #f00;
            padding: 15px 30px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 20px;
            cursor: pointer;
            text-transform: uppercase;
        }

        #game-over button:hover {
            background: #f00;
            color: #000;
        }

        #mobile-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050505;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            text-align: center;
            padding: 20px;
        }

        #mobile-warning h1 {
            color: #f00;
            border-bottom: 1px solid #f00;
            padding-bottom: 10px;
            font-size: 24px;
        }

        #mobile-warning p {
            color: #0f0;
            font-size: 16px;
            margin-top: 20px;
            max-width: 400px;
            line-height: 1.5;
        }

        .briefing-header {
            background: #001100;
            padding: 8px 15px;
            border-bottom: 1px solid #0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .briefing-title {
            color: #0f0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .briefing-close {
            color: #0f0;
            cursor: pointer;
            font-size: 14px;
            padding: 0 5px;
            border: 1px solid #0f0;
            background: transparent;
            transition: all 0.2s;
        }

        .briefing-close:hover {
            background: #0f0;
            color: #000;
        }

        .briefing-content {
            padding: 20px;
            display: flex;
            gap: 20px;
        }

        .commander-image {
            width: 120px;
            height: 120px;
            border: 2px solid #0f0;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            background: #000;
        }

        .commander-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: contrast(1.2) brightness(0.9);
        }

        .commander-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.3), transparent);
            animation: scanline 3s infinite;
        }

        @keyframes scanline {
            0% {
                left: -100%;
            }

            100% {
                left: 100%;
            }
        }

        .briefing-message {
            flex: 1;
            color: #0f0;
        }

        .message-sender {
            color: #ffff00;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .message-text {
            font-size: 14px;
            line-height: 1.6;
            color: #0f0;
            height: 100px;
            /* Fixed height */
            overflow-y: auto;
            /* Scrollable */
            scrollbar-width: thin;
            scrollbar-color: #0f0 #001100;
        }

        .message-text::-webkit-scrollbar {
            width: 6px;
        }

        .message-text::-webkit-scrollbar-track {
            background: #001100;
        }

        .message-text::-webkit-scrollbar-thumb {
            background-color: #0f0;
            border-radius: 3px;
        }

        .typewriter {
            overflow: hidden;
            white-space: pre-wrap;
            animation: typing 0.05s steps(1) infinite;
        }

        @keyframes typing {
            from {
                border-right: 2px solid #0f0;
            }

            to {
                border-right: 2px solid transparent;
            }
        }

        .briefing-footer {
            padding: 10px 20px;
            border-top: 1px solid #0f0;
            text-align: right;
            font-size: 11px;
            color: #8f8;
            opacity: 0.7;
        }

        .project-tag {
            font-size: 10px;
            padding: 1px 4px;
            border: 1px solid #0f0;
            border-radius: 2px;
            margin-left: 5px;
            color: #0f0;
            text-transform: uppercase;
            vertical-align: middle;
            opacity: 0.8;
        }

        .project-link {
            color: #fff;
            text-decoration: none;
            border-bottom: 1px dotted #fff;
            transition: color 0.2s;
        }

        .project-link:hover {
            color: #0f0;
            border-bottom: 1px solid #0f0;
        }
    </style>
</head>

<body>

    <div class="scanlines"></div>

    <!-- Game Over Screen -->
    <div id="game-over">
        <h1>MISSION FAILED</h1>
        <p style="color: #f88; margin-bottom: 20px; font-size: 18px;">AUGUSTIN'S BASES DESTROYED</p>

        <div id="score-submission" style="margin-bottom: 20px; text-align: center;">
            <p>FINAL SCORE: <span id="final-score" style="color: #ffff00;">0</span></p>
            <input type="text" id="pilot-name" placeholder="ENTER PILOT NAME" maxlength="10"
                style="background: #001100; border: 1px solid #0f0; color: #0f0; padding: 10px; font-family: 'Share Tech Mono'; text-transform: uppercase; margin-right: 10px;">
            <button onclick="submitScore()" style="padding: 10px 20px;">SUBMIT</button>
        </div>

        <div id="leaderboard"
            style="margin-bottom: 30px; width: 300px; text-align: left; border: 1px solid #0f0; padding: 10px; background: rgba(0, 17, 0, 0.8);">
            <h3 style="margin: 0 0 10px 0; border-bottom: 1px solid #0f0; color: #ffff00;">TOP PILOTS</h3>
            <ul id="leaderboard-list" style="list-style: none; padding: 0; margin: 0; font-size: 14px;">
                <li>LOADING...</li>
            </ul>
        </div>

        <button onclick="location.reload()">RETRY MISSION</button>
    </div>

    <!-- Mobile Warning -->
    <div id="mobile-warning">
        <h1>// SYSTEM INCOMPATIBLE</h1>
        <p>This tactical interface requires a keyboard and larger screen for optimal performance.</p>
        <p>Please access via a <strong>Desktop Terminal</strong> to benefit from the full experience.</p>
    </div>

    <!-- Start Screen -->
    <div id="start-screen"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 5, 0, 0.95); z-index: 9000; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer;">
        <h1 style="font-size: 40px; color: #0f0; text-shadow: 0 0 20px #0f0; animation: blink 1s infinite;">// SYSTEM
            READY</h1>
        <p style="color: #fff; font-size: 18px; margin-top: 20px;">[ CLICK TO INITIALIZE INTERFACE ]</p>
    </div>

    <!-- Pause Screen -->
    <div id="pause-screen"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 8000; display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: none;">
        <h1 style="font-size: 60px; color: #ffff00; text-shadow: 0 0 20px #ffff00; letter-spacing: 10px;">PAUSED</h1>
    </div>

    <style>
        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }
    </style>

    <!-- Mission Briefing -->
    <div id="mission-briefing">
        <div class="briefing-header">
            <span class="briefing-title">‚ö° INCOMING TRANSMISSION</span>
            <button class="briefing-close" onclick="closeBriefing()">X</button>
        </div>
        <div class="briefing-content">
            <div class="commander-image">
                <img src="./matrix.png" alt="Commander"
                    onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgZmlsbD0iIzAwMTEwMCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmaWxsPSIjMGYwIiBmb250LWZhbWlseT0ibW9ub3NwYWNlIiBmb250LXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+W05PIElNQUdFXTwvdGV4dD48L3N2Zz4='">
            </div>
            <div class="briefing-message">
                <div class="message-sender">COMMANDER Augustin</div>
                <div class="message-text" id="briefing-text"></div>
            </div>
        </div>
        <div class="briefing-footer">
            Press [SPACE] to continue ‚Ä¢ Sector: ALPHA-9 ‚Ä¢ Status: ACTIVE
        </div>
    </div>

    <div id="ui-layer">

        <!-- Audio Control -->
        <div id="audio-toggle" onclick="toggleAudio()" style="pointer-events: auto;">
            <div class="audio-label">AUDIO</div>
            <span id="audio-icon">üîä</span>
            <div class="audio-credits">
                Music by <a
                    href="https://pixabay.com/users/nickpanek-38266323/?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=357518"
                    target="_blank">Nicholas Panek</a> from <a
                    href="https://pixabay.com/music//?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=357518"
                    target="_blank">Pixabay</a>
            </div>
        </div>

        <!-- HUD Panel -->
        <div class="hud-panel">
            <h1>Tactical View</h1>
            <div class="sub-text">Sector: Alpha-9</div>
            <div class="sub-text" id="coords">Pos: 0, 0</div>
            <div style="margin-top: 10px; border-top: 1px solid #0f0; padding-top: 5px;">
                <div class="resource-row">
                    <span>SCORE:</span> <span id="score-val" class="resource-val">0</span>
                </div>
                <div class="resource-row">
                    <span>CARBON:</span> <span id="carbon-val" class="resource-val" style="color: #ffff00;">10</span>
                </div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div id="controls-hint">
            <div class="panel-label">CONTROLS [C]</div>

            <span class="sub-text">NAV:</span>
            <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span>
            <span class="sub-text">|</span>

            <span class="sub-text">BOOST:</span>
            <span class="key">SPACE</span>
            <span class="sub-text">|</span>

            <span class="sub-text">FIRE:</span>
            <span class="key">ENTER</span>
            <span class="sub-text">|</span>

            <span class="sub-text">BUILD:</span>
            <span class="key">B</span>
        </div>

        <!-- Construction Panel -->
        <div id="construction-panel">
            <div class="build-card" id="card-basic-tower" onclick="selectTower('basic')">
                <div class="card-icon">‚ôú</div>
                <div class="card-title">BASIC TOWER</div>
                <div class="card-cost">10 CARBON</div>
            </div>
            <div class="build-card" id="card-factory" onclick="selectTower('factory')" style="margin-left: 10px;">
                <div class="card-icon">üè≠</div>
                <div class="card-title">CARBON FACTORY</div>
                <div class="card-cost">10 CARBON</div>
            </div>
        </div>

        <!-- Radar Panel -->
        <div id="minimap-container">
            <div class="panel-label">RADAR [M]</div>
            <canvas id="minimap-canvas" width="200" height="200"></canvas>
        </div>
    </div>

    <!-- Modals -->
<div id="modal-about" class="modal">
  <span class="close-btn" onclick="closeModal()">[X]</span>
  <h2>// Base Station: Alpha</h2>

  <img src="./augustin.jpeg" alt="Operator"
    style="display:block;margin:0 auto 15px auto;width:120px;border:2px solid #0f0;border-radius:50%;object-fit:cover;">

  <p><strong>Operator:</strong> Augustin Romaneschi</p>

  <p><strong>Role:</strong></p>
  <p style="color:#cfc;margin-left:20px;">
    <span style="color:#ffff00;">‚ñ∫</span> Go To Market Engineer. Outbound systems builder<br>
    <span style="color:#ffff00;">‚ñ∫</span> Cold email and automation. Clay workflows. Data enrichment<br>
    <span style="color:#00ffff;">‚Üí</span> Hybrid profile. Business development √ó technical execution
  </p>

  <p><strong>Mission Profile:</strong></p>
  <p>
    I build outbound engines that reliably create qualified B2B meetings. I‚Äôm currently optimizing focus, routines, and
    long-term stability while preparing my next professional step and future company.
  </p>

  <p><strong>Core Capabilities:</strong></p>
  <p style="color:#cfc;margin-left:20px;">
    <span style="color:#0f0;">‚óÜ</span> GTM automation. Clay. Smartlead. Trigger-based outbound<br>
    <span style="color:#0f0;">‚óÜ</span> Prospecting systems. Decision maker mapping. Signal-driven lists<br>
    <span style="color:#0f0;">‚óÜ</span> Copy frameworks. Personalization at scale. Deliverability hygiene<br>
    <span style="color:#0f0;">‚óÜ</span> Operational discipline from endurance sport. Cycling Z2. Z3 mindset
  </p>

  <p><strong>Philosophy:</strong></p>
  <p style="font-style:italic;color:#8f8;border-left:2px solid #0f0;padding-left:15px;margin:15px 0;">
    "Build systems that create leverage. Ship small improvements daily. Protect attention like it‚Äôs a scarce resource."
  </p>

  <p style="text-align:center;margin-top:20px;color:#ffff00;font-size:12px;">
    [ STATUS: OPEN TO OPPORTUNITIES | LOCATION: SWITZERLAND ]
  </p>
</div>


   <!-- ‚úÖ PROJECTS MODAL. REPLACE YOUR #modal-projects BLOCK WITH THIS -->
<div id="modal-projects" class="modal">
  <span class="close-btn" onclick="closeModal()">[X]</span>
  <h2>// Augustin Romaneschi</h2>

  <p><strong>Go To Market Engineer</strong></p>
  <p>
    I build end to end outbound systems that turn targeted data into booked meetings. I‚Äôm focused on automation,
    list quality, personalization, and campaign operations.
  </p>

  <p><strong>Featured Ops and Builds:</strong></p>
  <ul style="padding-left:20px;line-height:1.6;">
    <li style="margin-bottom:10px;">
      <strong>Jiji Agency</strong> <span class="project-tag">DFY</span>:
      Done for you B2B lead gen. 4 to 6 qualified meetings per month with decision makers for high ticket offers.
    </li>
    <li style="margin-bottom:10px;">
      <strong>P.R.I.M.E. Method</strong> <span class="project-tag">SYSTEM</span>:
      Prospecting. Relevance. Inbox. Messaging. Execution. A repeatable outbound operating model.
    </li>
    <li style="margin-bottom:10px;">
      <strong>Signal based targeting</strong> <span class="project-tag">AI</span>:
      Finding real buyers when titles don‚Äôt match reality. Triggers. Job posts. Company changes. Context cues.
    </li>
    <li style="margin-bottom:10px;">
      <strong>Personalized cold email</strong> <span class="project-tag">COPY</span>:
      Short. Specific. Value first. Clean deliverability. Multi step follow up that feels human.
    </li>
    <li style="margin-bottom:10px;">
      <strong>Portfolio</strong> <span class="project-tag">LINK</span>:
      <a class="project-link" target="_blank"
        href="https://www.notion.so/Hi-I-m-Augustin-2aea72962f8280138c42e26a80b45788?source=copy_link">
        Open my portfolio hub
      </a>
    </li>
  </ul>

  <p style="margin-top:20px;border-top:1px dashed #0f0;padding-top:10px;">
    <a href="./CV.pdf" target="_blank" style="color:#0f0;text-decoration:none;font-weight:bold;">
      [DOWNLOAD CV .PDF]
    </a>
  </p>
</div>


    <div id="modal-contact" class="modal">
        <span class="close-btn" onclick="closeModal()">[X]</span>
        <h2>// Comms Relay</h2>
        <p>Frequency Open.</p>
        <p>Email: <a href="mailto:augustin.romaneschi@gmail.com" style="color: #0f0; text-decoration: none;">augustin.romaneschi@gmail.com</a></p>
        <p>
            <a href="https://x.com/Augustinrrr" target="_blank"
                style="color: #0f0; margin-right: 15px; text-decoration: none; border-bottom: 1px dashed #0f0;">[X /
                TWITTER]</a>
            <a href="https://www.linkedin.com/in/augustinr/" target="_blank"
                style="color: #0f0; text-decoration: none; border-bottom: 1px dashed #0f0;">[LINKEDIN]</a>
        </p>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // --- SUPABASE SETUP ---
        // For Vercel: build.js replaces these placeholders during build with environment variables
        // The placeholders are replaced by build.js during Vercel deployment
        const SUPABASE_URL = 'VERCEL_SUPABASE_URL_PLACEHOLDER';
        const SUPABASE_KEY = 'VERCEL_SUPABASE_KEY_PLACEHOLDER';

        // Initialize Supabase client (use 'db' to avoid conflict with global 'supabase')
        let db = null;
        if (SUPABASE_URL && SUPABASE_KEY &&
            !SUPABASE_URL.includes('PLACEHOLDER') &&
            !SUPABASE_KEY.includes('PLACEHOLDER')) {
            db = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        } else {
            console.warn("Supabase not configured. For Vercel: set SUPABASE_URL and SUPABASE_ANON_KEY environment variables.");
        }

        // --- CONFIG ---
        const CONFIG = {
            moveSpeed: 0.4,
            boostSpeed: 1.2,
            turnSpeed: 0.1,
            friction: 0.92,
            camZoom: 40,
            mapBounds: 100, // Wrap at +/- 100
            colors: {
                bg: 0x050505,
                grid: 0x003300,
                ship: 0x00ff00,
                asteroid: 0x224422,
                planet: 0x001100,
                projectile: 0xffff00,
                enemy: 0xff0000,
                enemyLaser: 0xff3333
            },
            attackDelay: 20000, // 20 seconds before first attack
            baseMaxHealth: 150
        };

        // --- STATE ---
        const STATE = {
            velocity: new THREE.Vector3(),
            keys: {
                w: false, a: false, s: false, d: false,
                ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false,
                " ": false, Enter: false, m: false, c: false, b: false
            },
            modalOpen: false,
            lastShotTime: 0,
            projectiles: [],
            enemies: [],
            towers: [],
            factories: [],
            mapVisible: true,
            controlsVisible: true,
            briefingShown: false,
            audioEnabled: true,
            gameActive: true,
            round: 0,
            waveInProgress: false,
            nextWaveTime: 0,
            score: 0,
            carbon: 10,
            buildMode: false,
            selectedBuilding: null,
            paused: false
        };

        // --- AUDIO SYSTEM ---
        const AUDIO = {
            bgMusic: null,
            laserSound: null,
            explosionSound: null,
            typingSound: null,
            initialized: false
        };

        function initAudio() {
            if (AUDIO.initialized) return;

            // Background Music
            AUDIO.bgMusic = new Audio('./cool_song.mp3');
            AUDIO.bgMusic.loop = true;
            AUDIO.bgMusic.volume = 0.3;

            // Laser Sound
            AUDIO.laserSound = new Audio('./laser.mp3');
            AUDIO.laserSound.volume = 0.2;

            // Explosion Sound
            AUDIO.explosionSound = new Audio('./explosion.mp3');
            AUDIO.explosionSound.volume = 0.3;

            // Typing Sound
            AUDIO.typingSound = new Audio('./text-writting.mp3');
            AUDIO.typingSound.loop = true;
            AUDIO.typingSound.volume = 0.2;

            // Manual loop fallback
            AUDIO.typingSound.addEventListener('ended', function () {
                this.currentTime = 0;
                this.play().catch(e => { });
            }, false);

            AUDIO.initialized = true;

            // Start background music
            if (STATE.audioEnabled) {
                AUDIO.bgMusic.play().catch(e => {
                    console.log('Audio autoplay blocked, will play on user interaction');
                });
            }
        }

        function toggleAudio() {
            STATE.audioEnabled = !STATE.audioEnabled;
            const icon = document.getElementById('audio-icon');
            const toggle = document.getElementById('audio-toggle');

            if (STATE.audioEnabled) {
                icon.textContent = 'üîä';
                toggle.classList.remove('muted');
                if (AUDIO.bgMusic) {
                    AUDIO.bgMusic.play().catch(e => console.log('Audio play failed'));
                }
            } else {
                icon.textContent = 'üîá';
                toggle.classList.add('muted');
                if (AUDIO.bgMusic) {
                    AUDIO.bgMusic.pause();
                }
            }
        }

        function playLaserSound() {
            if (!STATE.audioEnabled || !AUDIO.laserSound) return;
            // Clone and play to allow multiple simultaneous sounds
            const sound = AUDIO.laserSound.cloneNode();
            sound.volume = 0.2;  // Reduced from 0.5
            sound.play().catch(e => console.log('Laser sound failed'));
        }

        function playExplosionSound() {
            if (!STATE.audioEnabled || !AUDIO.explosionSound) return;
            // Clone and play to allow multiple simultaneous sounds
            const sound = AUDIO.explosionSound.cloneNode();
            sound.volume = 0.3;  // Reduced from 0.6
            sound.play().catch(e => console.log('Explosion sound failed'));
        }

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.bg);

        // ISOMETRIC CAMERA setup
        const aspect = window.innerWidth / window.innerHeight;
        const d = CONFIG.camZoom;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);

        // Classic Isometric Angle
        camera.position.set(20, 20, 20);
        camera.lookAt(scene.position);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- ENVIRONMENT ---

        // 1. The Grid (Tactical Floor)
        const gridHelper = new THREE.GridHelper(CONFIG.mapBounds * 2, 40, 0x00ff00, 0x002200);
        scene.add(gridHelper);

        // Hit Plane for Raycasting (Invisible)
        const hitPlaneGeo = new THREE.PlaneGeometry(CONFIG.mapBounds * 2, CONFIG.mapBounds * 2);
        const hitPlaneMat = new THREE.MeshBasicMaterial({ visible: false });
        const hitPlane = new THREE.Mesh(hitPlaneGeo, hitPlaneMat);
        hitPlane.rotation.x = -Math.PI / 2;
        scene.add(hitPlane);

        // 2. The Plane (Hero)
        const planeGroup = new THREE.Group();

        // Fuselage
        const fuselageGeo = new THREE.BoxGeometry(1.5, 0.5, 3);
        const planeMat = new THREE.MeshPhongMaterial({ color: 0x00cc00, shininess: 50 });
        const fuselage = new THREE.Mesh(fuselageGeo, planeMat);
        fuselage.castShadow = true;
        planeGroup.add(fuselage);

        // Wings
        const wingGeo = new THREE.BoxGeometry(6, 0.2, 1.5);
        const wings = new THREE.Mesh(wingGeo, planeMat);
        wings.position.set(0, 0, 0.5);
        wings.castShadow = true;
        planeGroup.add(wings);

        // Tail
        const tailGeo = new THREE.BoxGeometry(2, 0.2, 1);
        const tail = new THREE.Mesh(tailGeo, planeMat);
        tail.position.set(0, 0.5, -1.2);
        tail.castShadow = true;
        planeGroup.add(tail);

        // Cockpit
        const cockpitGeo = new THREE.BoxGeometry(0.8, 0.4, 1);
        const cockpitMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
        const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
        cockpit.position.set(0, 0.4, 0.5);
        planeGroup.add(cockpit);

        scene.add(planeGroup);

        // Trail particles array
        const trailParticles = [];


        // 3. Asteroids & Planets
        let asteroids = [];

        function createAsteroid(x, z, scale) {
            const geo = new THREE.IcosahedronGeometry(1, 0);
            const mat = new THREE.MeshPhongMaterial({
                color: CONFIG.colors.asteroid,
                flatShading: true,
                wireframe: false
            });
            const mesh = new THREE.Mesh(geo, mat);

            // Randomize shape slightly
            const posAttribute = geo.attributes.position;
            for (let i = 0; i < posAttribute.count; i++) {
                posAttribute.setXYZ(
                    i,
                    posAttribute.getX(i) + (Math.random() - 0.5) * 0.5,
                    posAttribute.getY(i) + (Math.random() - 0.5) * 0.5,
                    posAttribute.getZ(i) + (Math.random() - 0.5) * 0.5
                );
            }
            geo.computeVertexNormals();

            mesh.position.set(x, Math.random() * 2 + 1, z);
            mesh.scale.set(scale, scale, scale);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            // Random rotation
            mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);

            scene.add(mesh);
            asteroids.push({ mesh, rotSpeed: (Math.random() - 0.5) * 0.02, radius: scale });
        }

        // --- TOWER SYSTEM ---
        function createTower(x, z) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            // Base
            const baseGeo = new THREE.CylinderGeometry(1, 1.5, 1, 8);
            const baseMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 0.5;
            group.add(base);

            // Turret
            const turretGeo = new THREE.BoxGeometry(1, 0.8, 1.5);
            const turretMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            const turret = new THREE.Mesh(turretGeo, turretMat);
            turret.position.y = 1.4;
            group.add(turret);

            // Barrel
            const barrelGeo = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
            const barrelMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 1.4, 1);
            group.add(barrel);

            scene.add(group);

            STATE.towers.push({
                group: group,
                turret: turret,
                range: 40,
                fireRate: 1000, // Faster fire rate
                lastShot: 0,
                damage: 50 // High damage (2 shots to kill 100hp enemy)
            });

            // Effect
            createExplosion(new THREE.Vector3(x, 0, z), 0xffff00, 2);
        }

        function updateTowers() {
            const now = Date.now();
            STATE.towers.forEach(tower => {
                // Find nearest enemy
                let nearest = null;
                let minDst = tower.range;

                STATE.enemies.forEach(e => {
                    const d = tower.group.position.distanceTo(e.mesh.position);
                    if (d < minDst) {
                        minDst = d;
                        nearest = e;
                    }
                });

                if (nearest) {
                    // Rotate turret
                    tower.turret.lookAt(nearest.mesh.position);

                    // Fire
                    if (now - tower.lastShot > tower.fireRate) {
                        tower.lastShot = now;
                        fireTower(tower, nearest);
                    }
                }
            });
        }

        // --- FACTORY SYSTEM ---
        function createFactory(x, z) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            // Sci-Fi Base (Hexagonal)
            const baseGeo = new THREE.CylinderGeometry(2.5, 3, 1, 6);
            const baseMat = new THREE.MeshPhongMaterial({ color: 0x222222, flatShading: true });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 0.5;
            group.add(base);

            // Energy Core (Glowing)
            const coreGeo = new THREE.CylinderGeometry(1, 1, 3, 8);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.y = 2;
            group.add(core);

            // Rotating Ring
            const ringGeo = new THREE.TorusGeometry(2, 0.2, 8, 16);
            const ringMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 2;
            group.add(ring);

            // Top Cap
            const capGeo = new THREE.ConeGeometry(1.5, 1, 6);
            const capMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 4;
            group.add(cap);

            // Energy Particles (reusing smoke logic but making it energy)
            const smokeGeo = new THREE.IcosahedronGeometry(0.3, 0);
            const smokeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const smoke = new THREE.Mesh(smokeGeo, smokeMat);
            smoke.position.set(0, 4, 0);
            smoke.visible = false;
            group.add(smoke);

            // Health Bar
            const healthCanvas = document.createElement('canvas');
            healthCanvas.width = 64; healthCanvas.height = 8;
            const hCtx = healthCanvas.getContext('2d');
            hCtx.fillStyle = '#000000'; hCtx.fillRect(0, 0, 64, 8);
            hCtx.fillStyle = '#00ffff'; hCtx.fillRect(1, 1, 62, 6);

            const healthTex = new THREE.CanvasTexture(healthCanvas);
            const healthMat = new THREE.SpriteMaterial({ map: healthTex });
            const healthBar = new THREE.Sprite(healthMat);
            healthBar.scale.set(6, 0.8, 1);
            healthBar.position.set(0, 6, 0);
            healthBar.visible = false;
            group.add(healthBar);

            scene.add(group);

            STATE.factories.push({
                group: group,
                smoke: smoke,
                ring: ring,
                health: 100, // 10 shots from standard enemy (10 dmg)
                maxHealth: 100,
                healthBar: healthBar,
                healthCanvas: healthCanvas,
                healthCtx: hCtx,
                healthTex: healthTex,
                lastDamageTime: 0,
                lastGen: Date.now(),
                genRate: 7000
            });

            createExplosion(new THREE.Vector3(x, 0, z), 0x00ffff, 2);
        }

        function updateFactories() {
            const now = Date.now();
            STATE.factories.forEach(f => {
                // Generation
                if (now - f.lastGen > f.genRate) {
                    f.lastGen = now;
                    STATE.carbon += 1;
                    document.getElementById('carbon-val').innerText = STATE.carbon;

                    // Visual effect
                    f.smoke.visible = true;
                    f.smoke.scale.set(1, 1, 1);
                    f.smoke.position.y = 4;
                    setTimeout(() => { f.smoke.visible = false; }, 1000);
                }

                // Animate smoke (Energy Pulse)
                if (f.smoke.visible) {
                    f.smoke.position.y += 0.1;
                    f.smoke.scale.multiplyScalar(1.05);
                    f.smoke.material.opacity -= 0.02;
                }

                // Animate Ring
                if (f.ring) {
                    f.ring.rotation.z += 0.02;
                    f.ring.rotation.x = Math.PI / 2 + Math.sin(now * 0.002) * 0.2;
                }

                // Health Bar Visibility
                const dist = planeGroup.position.distanceTo(f.group.position);
                const recentlyDamaged = Date.now() - f.lastDamageTime < 3000;

                if (dist < 30 || recentlyDamaged) {
                    f.healthBar.visible = true;

                    // Update Bar
                    const ctx = f.healthCtx;
                    const pct = Math.max(0, f.health / f.maxHealth);
                    ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, 64, 8);
                    ctx.fillStyle = '#00ffff'; ctx.fillRect(1, 1, 62 * pct, 6);
                    f.healthTex.needsUpdate = true;
                } else {
                    f.healthBar.visible = false;
                }
            });
        }

        function fireTower(tower, target) {
            const geo = new THREE.BoxGeometry(0.4, 0.4, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(geo, mat);

            bullet.position.copy(tower.group.position);
            bullet.position.y = 1.4; // Turret height
            bullet.lookAt(target.mesh.position);

            const dir = new THREE.Vector3().subVectors(target.mesh.position, bullet.position).normalize();

            scene.add(bullet);
            STATE.projectiles.push({
                mesh: bullet,
                dir: dir,
                life: 100,
                isEnemy: false,
                isTower: true, // Mark as tower shot
                speed: 0.8 // Slow projectile
            });

            playLaserSound();
        }

        // Generate Field
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * 160;
            const z = (Math.random() - 0.5) * 160;
            if (Math.abs(x) < 10 && Math.abs(z) < 10) continue;
            createAsteroid(x, z, 1 + Math.random() * 2);
        }

        // 4. Planets / Bases (Interactive Points)
        let bases = [];

        function createBase(x, z, color, label, type) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            // Planet wireframe
            const geo = new THREE.IcosahedronGeometry(4, 1);
            const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true, transparent: true, opacity: 0.3 });
            const planet = new THREE.Mesh(geo, mat);
            group.add(planet);

            // Core
            const coreGeo = new THREE.OctahedronGeometry(1.5, 0);
            const coreMat = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.userData = { offset: Math.random() * 10 };
            group.add(core);

            // Label
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + new THREE.Color(color).getHexString();
            ctx.font = 'bold 30px "Share Tech Mono"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 128, 32);

            const tex = new THREE.CanvasTexture(canvas);
            const labelMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const labelSprite = new THREE.Sprite(labelMat);
            labelSprite.scale.set(10, 2.5, 1);
            labelSprite.position.y = 6;
            group.add(labelSprite);

            // Health Bar (Sprite - Always Horizontal)
            const healthCanvas = document.createElement('canvas');
            healthCanvas.width = 64; healthCanvas.height = 8;
            const hCtx = healthCanvas.getContext('2d');

            // Initial Draw
            hCtx.fillStyle = '#000000';
            hCtx.fillRect(0, 0, 64, 8);
            hCtx.fillStyle = '#ff0000';
            hCtx.fillRect(1, 1, 62, 6); // 1px border

            const healthTex = new THREE.CanvasTexture(healthCanvas);
            const healthMat = new THREE.SpriteMaterial({ map: healthTex });
            const healthBar = new THREE.Sprite(healthMat);
            healthBar.scale.set(8, 1, 1);
            healthBar.position.set(0, 8, 0);
            healthBar.visible = false;
            group.add(healthBar);

            // Repair Icon (+)
            const repairCanvas = document.createElement('canvas');
            repairCanvas.width = 64; repairCanvas.height = 64;
            const rCtx = repairCanvas.getContext('2d');
            rCtx.fillStyle = '#00ff00';
            rCtx.font = 'bold 60px Arial';
            rCtx.textAlign = 'center';
            rCtx.textBaseline = 'middle';
            rCtx.fillText('+', 32, 34);

            const repairTex = new THREE.CanvasTexture(repairCanvas);
            const repairMat = new THREE.SpriteMaterial({ map: repairTex, transparent: true });
            const repairIcon = new THREE.Sprite(repairMat);
            repairIcon.scale.set(2, 2, 1);
            repairIcon.position.set(5, 8, 0); // Right of health bar
            repairIcon.visible = false;
            group.add(repairIcon);

            // Floor Ring
            const ringGeo = new THREE.RingGeometry(5, 5.2, 32);
            ringGeo.rotateX(-Math.PI / 2);
            const ringMat = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.y = 0.1;
            group.add(ring);

            scene.add(group);
            bases.push({
                group,
                core,
                type,
                radius: 5,
                colorString: '#' + new THREE.Color(color).getHexString(),
                health: CONFIG.baseMaxHealth,
                maxHealth: CONFIG.baseMaxHealth,
                healthBar: healthBar,
                healthCanvas: healthCanvas,
                healthCtx: hCtx,
                healthTex: healthTex,
                repairIcon: repairIcon,
                lastDamageTime: 0
            });
        }

        function updateHealthBar(base) {
            const ctx = base.healthCtx;
            const w = base.healthCanvas.width;
            const h = base.healthCanvas.height;
            const pct = Math.max(0, base.health / base.maxHealth);

            // Background (Black border)
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, w, h);

            // Health (Red)
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(1, 1, (w - 2) * pct, h - 2);

            base.healthTex.needsUpdate = true;
        }

        createBase(-30, -30, 0x00ffff, "ABOUT_BASE", "about");
        createBase(30, -20, 0xff00ff, "PROJECT_HUB", "projects");
        createBase(0, 40, 0xffff00, "COMMS_RELAY", "contact");

        // --- ENEMY SYSTEM ---
        function createEnemyShip(type = 'basic') {
            const group = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color: CONFIG.colors.enemy, shininess: 30 });

            if (type === 'cargo') {
                // CARGO SHIP (Big, Long)
                const fuselageGeo = new THREE.BoxGeometry(4, 2, 10);
                const fuselage = new THREE.Mesh(fuselageGeo, mat);
                fuselage.castShadow = true;
                group.add(fuselage);

                // Side Pods
                const podGeo = new THREE.CylinderGeometry(1, 1, 8, 8);
                const leftPod = new THREE.Mesh(podGeo, mat);
                leftPod.rotation.x = Math.PI / 2;
                leftPod.position.set(-3, 0, 0);
                group.add(leftPod);

                const rightPod = new THREE.Mesh(podGeo, mat);
                rightPod.rotation.x = Math.PI / 2;
                rightPod.position.set(3, 0, 0);
                group.add(rightPod);
            } else {
                // BASIC SHIP
                const fuselageGeo = new THREE.BoxGeometry(1.5, 0.5, 2.5);
                const fuselage = new THREE.Mesh(fuselageGeo, mat);
                fuselage.castShadow = true;
                group.add(fuselage);

                const wingGeo = new THREE.BoxGeometry(4, 0.2, 1);
                const wings = new THREE.Mesh(wingGeo, mat);
                wings.position.set(0, 0, 0.5);
                wings.rotation.y = Math.PI;
                wings.castShadow = true;
                group.add(wings);
            }

            return group;
        }

        function spawnEnemy(type = 'basic') {
            if (bases.length === 0 && STATE.factories.length === 0) return;

            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.mapBounds - 10;
            const x = Math.sin(angle) * dist;
            const z = Math.cos(angle) * dist;

            const mesh = createEnemyShip(type);
            mesh.position.set(x, 2, z);

            scene.add(mesh);

            const targetBase = findClosestBase(mesh.position);

            const isCargo = type === 'cargo';

            STATE.enemies.push({
                mesh,
                type,
                target: targetBase,
                speed: isCargo ? 0.03 : 0.15, // Cargo is extremely slow
                lastShot: 0,
                fireRate: isCargo ? 4000 : 2000, // Cargo fires slower
                health: isCargo ? 2000 : 100, // 20 shots vs 1 shot (Player dmg 100)
                maxHealth: isCargo ? 2000 : 100,
                damage: isCargo ? 25 : 10 // Cargo hits harder (25 dmg)
            });
        }

        function findClosestBase(pos) {
            let closest = null;
            let minDst = Infinity;

            // Check Bases
            bases.forEach(b => {
                const d = pos.distanceTo(b.group.position);
                if (d < minDst) {
                    minDst = d;
                    closest = { type: 'base', obj: b, pos: b.group.position };
                }
            });

            // Check Factories
            STATE.factories.forEach(f => {
                const d = pos.distanceTo(f.group.position);
                if (d < minDst) {
                    minDst = d;
                    closest = { type: 'factory', obj: f, pos: f.group.position };
                }
            });

            return closest;
        }

        function updateEnemies() {
            const now = Date.now();

            for (let i = STATE.enemies.length - 1; i >= 0; i--) {
                const e = STATE.enemies[i];

                // Re-evaluate target
                if (!e.target || (e.target.type === 'base' && !bases.includes(e.target.obj)) || (e.target.type === 'factory' && !STATE.factories.includes(e.target.obj))) {
                    e.target = findClosestBase(e.mesh.position);
                    if (!e.target) continue; // No targets left
                }

                const distToTarget = e.mesh.position.distanceTo(e.target.pos);
                const attackRange = 25;

                // Look at target
                e.mesh.lookAt(e.target.pos);

                // Move if out of range
                if (distToTarget > attackRange) {
                    const dir = new THREE.Vector3().subVectors(e.target.pos, e.mesh.position);
                    dir.y = 0;
                    dir.normalize();
                    e.mesh.position.add(dir.multiplyScalar(e.speed));
                } else {
                    // Attack Logic
                    if (now - e.lastShot > e.fireRate) {
                        enemyShoot(e);
                        e.lastShot = now;
                    }
                }

                // Collision with Player/Tower Projectiles
                for (let j = STATE.projectiles.length - 1; j >= 0; j--) {
                    const p = STATE.projectiles[j];
                    if (p.isEnemy) continue; // Don't hit self

                    // Increased hitbox size from 2.5 to 6.0 for easier aiming
                    if (p.mesh.position.distanceTo(e.mesh.position) < 6.0) {
                        // Damage Calculation
                        const damage = p.isTower ? 50 : 100; // Tower: 2 shots, Player: 1 shot
                        e.health -= damage;

                        // Remove Projectile
                        scene.remove(p.mesh);
                        STATE.projectiles.splice(j, 1);

                        // Flash effect
                        e.mesh.children.forEach(c => {
                            if (c.material) {
                                const old = c.material.emissive.getHex();
                                c.material.emissive.setHex(0xffffff);
                                setTimeout(() => { if (c.material) c.material.emissive.setHex(old); }, 50);
                            }
                        });

                        if (e.health <= 0) {
                            // Enemy Destroyed
                            createExplosion(e.mesh.position, 0xffaa00);
                            scene.remove(e.mesh);
                            STATE.enemies.splice(i, 1);

                            // Score
                            STATE.score += 100;
                            document.getElementById('score-val').innerText = STATE.score;

                            playExplosionSound();
                        } else {
                            // Hit sound but not destroyed
                            playLaserSound();
                        }
                        break;
                    }
                }
            }
        }

        function enemyShoot(enemy) {
            const isCargo = enemy.type === 'cargo';
            const scale = isCargo ? 2 : 1;

            const geo = new THREE.BoxGeometry(0.4 * scale, 0.4 * scale, 1.5 * scale);
            const mat = new THREE.MeshBasicMaterial({ color: isCargo ? 0xff0000 : CONFIG.colors.enemyLaser });
            const bullet = new THREE.Mesh(geo, mat);

            bullet.position.copy(enemy.mesh.position);
            bullet.lookAt(enemy.target.pos);

            const direction = new THREE.Vector3().subVectors(enemy.target.pos, enemy.mesh.position).normalize();

            scene.add(bullet);

            STATE.projectiles.push({
                mesh: bullet,
                dir: direction,
                life: 400,
                isEnemy: true,
                speed: 0.15,
                damage: enemy.damage || 10
            });
            playLaserSound();
        }

        function damageBase(base, amount) {
            base.health -= amount;
            base.lastDamageTime = Date.now();

            // Update Health Bar Texture
            updateHealthBar(base);

            // Flash effect
            base.core.material.emissiveIntensity = 2;
            setTimeout(() => { if (base.core) base.core.material.emissiveIntensity = 0.5; }, 100);

            if (base.health <= 0) {
                // Destroy Base
                createExplosion(base.group.position, 0x00ffff, 5);
                scene.remove(base.group);
                bases = bases.filter(b => b !== base);
                playExplosionSound();

                if (bases.length === 0) {
                    gameOver();
                } else if (bases.length === 1) {
                    showTransmission("‚ö†Ô∏è WARNING: CRITICAL LOSSES DETECTED.\n\nONLY ONE BASE REMAINS.\n\nDEFEND IT AT ALL COSTS, PILOT!");
                }
            }
        }

        let briefingCloseTimer = null;

        function showTransmission(message) {
            if (briefingCloseTimer) clearTimeout(briefingCloseTimer);

            const briefing = document.getElementById('mission-briefing');
            const textElement = document.getElementById('briefing-text');

            // Force display reset
            briefing.style.display = 'block';
            briefing.style.opacity = '1';
            briefing.style.transform = 'translateY(0)';

            // Reset
            briefing.classList.remove('active');
            void briefing.offsetWidth; // Trigger reflow

            textElement.textContent = "";
            briefing.classList.add('active');

            // Start Audio
            if (STATE.audioEnabled && AUDIO.typingSound) {
                AUDIO.typingSound.currentTime = 0;
                AUDIO.typingSound.play().catch(e => console.log("Audio play failed:", e));
            }

            // Custom typewriter for dynamic messages
            let index = 0;
            textElement.classList.add('typewriter');

            const typeInterval = setInterval(() => {
                if (index < message.length) {
                    textElement.textContent = message.substring(0, index + 1);
                    textElement.scrollTop = textElement.scrollHeight; // Auto-scroll
                    index++;
                } else {
                    clearInterval(typeInterval);
                    textElement.classList.remove('typewriter');
                    if (AUDIO.typingSound) AUDIO.typingSound.pause();
                    setTimeout(() => closeBriefing(), 8000);
                }
            }, 30);
        }

        function createExplosion(pos, color, scale = 1) {
            const expGeo = new THREE.SphereGeometry(1 * scale, 8, 8);
            const expMat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const exp = new THREE.Mesh(expGeo, expMat);
            exp.position.copy(pos);
            scene.add(exp);
            trailParticles.push({ mesh: exp, life: 0.5, type: 'explosion' });
        }

        function updateBases() {
            bases.forEach(base => {
                // Health Bar Visibility
                const dist = planeGroup.position.distanceTo(base.group.position);
                const recentlyDamaged = Date.now() - base.lastDamageTime < 3000;

                if (dist < 40 || recentlyDamaged) {
                    base.healthBar.visible = true;

                    // Show Repair Icon if damaged
                    if (base.health < base.maxHealth) {
                        base.repairIcon.visible = true;
                        // Pulse effect
                        const scale = 2 + Math.sin(Date.now() * 0.005) * 0.2;
                        base.repairIcon.scale.set(scale, scale, 1);
                    } else {
                        base.repairIcon.visible = false;
                    }
                } else {
                    base.healthBar.visible = false;
                    base.repairIcon.visible = false;
                }
            });
        }

        function updateGameLogic() {
            if (!STATE.gameActive) return;

            const now = Date.now();

            // Initial Delay
            if (STATE.round === 0) {
                if (!STATE.nextWaveTime) STATE.nextWaveTime = now + CONFIG.attackDelay;
                if (now > STATE.nextWaveTime) {
                    startNextRound();
                }
                return;
            }

            // Check Wave Status
            if (STATE.waveInProgress && STATE.enemies.length === 0) {
                STATE.waveInProgress = false;
                STATE.nextWaveTime = now + 5000; // Increased to 5 seconds between rounds
            }

            // Start Next Round
            if (!STATE.waveInProgress && now > STATE.nextWaveTime) {
                startNextRound();
            }
        }

        function startNextRound() {
            STATE.round++;
            STATE.waveInProgress = true;

            // Slower progression: 1, 1, 2, 2, 3, 3...
            const count = Math.ceil(STATE.round / 2);

            // Briefing update for round
            const briefing = document.getElementById('mission-briefing');
            if (!briefing.classList.contains('active')) {
                // Optional: Flash a message about incoming wave
            }

            for (let i = 0; i < count; i++) {
                // Stagger spawns significantly (5 seconds between each enemy arrival)
                setTimeout(() => spawnEnemy('basic'), i * 5000);
            }

            // Cargo Ship Logic (Round 10+)
            if (STATE.round >= 10) {
                setTimeout(() => {
                    showTransmission("WARNING: CARGO CLASS HOSTILE DETECTED.");
                    spawnEnemy('cargo');
                }, 10000);
            }
        }

        function gameOver() {
            STATE.gameActive = false;
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('final-score').innerText = STATE.score;
            fetchLeaderboard();
        }

        async function submitScore() {
            if (!db) {
                alert("Supabase not configured! Check index.htm");
                return;
            }

            const name = document.getElementById('pilot-name').value.trim() || 'UNKNOWN';
            const score = STATE.score;

            const { error } = await db
                .from('leaderboard')
                .insert({ username: name, score: score });

            if (error) {
                console.error('Error submitting score:', error);
                alert('Error submitting score');
            } else {
                document.getElementById('score-submission').innerHTML = '<p style="color: #0f0;">SCORE TRANSMITTED</p>';
                fetchLeaderboard();
            }
        }

        async function fetchLeaderboard() {
            if (!db) return;

            const { data, error } = await db
                .from('leaderboard')
                .select('*')
                .order('score', { ascending: false })
                .limit(5);

            const list = document.getElementById('leaderboard-list');
            list.innerHTML = '';

            if (error) {
                list.innerHTML = '<li style="color: #f00;">ERROR FETCHING DATA</li>';
            } else {
                data.forEach((entry, index) => {
                    const li = document.createElement('li');
                    li.style.display = 'flex';
                    li.style.justifyContent = 'space-between';
                    li.style.marginBottom = '5px';
                    li.innerHTML = `
                        <span>${index + 1}. ${entry.username}</span>
                        <span style="color: #ffff00;">${entry.score}</span>
                    `;
                    list.appendChild(li);
                });
            }
        }


        // --- INPUT HANDLING ---
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (STATE.buildMode && STATE.selectedBuilding) {
                    STATE.selectedBuilding = null;
                    removeGhost();
                    updateUI();
                } else {
                    closeModal();
                }
            }
            if (STATE.keys.hasOwnProperty(e.key) || STATE.keys.hasOwnProperty(e.code)) {
                STATE.keys[e.key] = true;
                STATE.keys[e.code] = true;
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleMinimap();
            }
            if (e.key === 'c' || e.key === 'C') {
                toggleControls();
            }
            if (e.key === 'b' || e.key === 'B') {
                toggleBuildMode();
            }
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (STATE.keys.hasOwnProperty(e.key) || STATE.keys.hasOwnProperty(e.code)) {
                STATE.keys[e.key] = false;
                STATE.keys[e.code] = false;
            }
        });

        function toggleMinimap() {
            STATE.mapVisible = !STATE.mapVisible;
            const mapEl = document.getElementById('minimap-container');
            mapEl.style.display = STATE.mapVisible ? 'block' : 'none';
        }

        function toggleControls() {
            STATE.controlsVisible = !STATE.controlsVisible;
            const ctrlEl = document.getElementById('controls-hint');
            ctrlEl.style.display = STATE.controlsVisible ? 'block' : 'none';
        }

        function togglePause() {
            STATE.paused = !STATE.paused;
            document.getElementById('pause-screen').style.display = STATE.paused ? 'flex' : 'none';
        }

        // --- MOUSE & RAYCASTING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let ghostTower = null;

        window.addEventListener('mousemove', (event) => {
            // Normalize mouse coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Left Click
                if (STATE.buildMode) {
                    tryBuildTower();
                }

                // Check for Base Repair Click
                checkBaseRepairClick();
            }
        });

        function checkBaseRepairClick() {
            raycaster.setFromCamera(mouse, camera);

            bases.forEach(base => {
                if (base.repairIcon.visible) {
                    const intersects = raycaster.intersectObject(base.repairIcon);
                    if (intersects.length > 0) {
                        // Repair Logic
                        if (STATE.carbon >= 5) {
                            if (base.health < base.maxHealth) {
                                STATE.carbon -= 5;
                                document.getElementById('carbon-val').innerText = STATE.carbon;

                                base.health = Math.min(base.maxHealth, base.health + 50);
                                updateHealthBar(base);

                                // Effect
                                createExplosion(base.group.position, 0x00ff00, 2);
                                showTransmission("BASE REPAIRED.");
                            } else {
                                showTransmission("BASE HEALTH FULL.");
                            }
                        } else {
                            showTransmission("INSUFFICIENT CARBON. NEED 5.");
                        }
                    }
                }
            });
        }

        window.selectTower = function (type) {
            STATE.selectedBuilding = type;
            createGhost();
            updateUI();
        }

        function toggleBuildMode() {
            STATE.buildMode = !STATE.buildMode;
            const panel = document.getElementById('construction-panel');
            panel.style.display = STATE.buildMode ? 'flex' : 'none';

            if (!STATE.buildMode) {
                STATE.selectedBuilding = null;
                removeGhost();
            }
        }

        function createGhost() {
            removeGhost(); // Clear existing
            if (!STATE.selectedBuilding) return;

            const group = new THREE.Group();

            if (STATE.selectedBuilding === 'basic') {
                // Tower Visual
                const geo = new THREE.CylinderGeometry(1, 1.5, 1, 8);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, wireframe: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.y = 0.5;
                group.add(mesh);

                // Range circle
                const ringGeo = new THREE.RingGeometry(29, 30, 32);
                ringGeo.rotateX(-Math.PI / 2);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.y = 0.1;
                group.add(ring);
            } else if (STATE.selectedBuilding === 'factory') {
                // Factory Visual (Ghost)
                const geo = new THREE.CylinderGeometry(2.5, 3, 1, 6);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, wireframe: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.y = 0.5;
                group.add(mesh);
            }

            scene.add(group);
            ghostTower = group;
        }

        function removeGhost() {
            if (ghostTower) {
                scene.remove(ghostTower);
                ghostTower = null;
            }
        }

        function updateGhost() {
            if (!STATE.buildMode || !ghostTower) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(hitPlane);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                ghostTower.position.set(point.x, 0, point.z);

                // Color indication
                const affordable = STATE.carbon >= 10;
                const color = affordable ? 0x00ff00 : 0xff0000;

                ghostTower.children.forEach(c => {
                    if (c.material) c.material.color.setHex(color);
                });
            }
        }

        function tryBuildTower() {
            if (!ghostTower || !STATE.selectedBuilding) return;

            if (STATE.carbon >= 10) {
                STATE.carbon -= 10;
                document.getElementById('carbon-val').innerText = STATE.carbon;

                if (STATE.selectedBuilding === 'basic') {
                    createTower(ghostTower.position.x, ghostTower.position.z);
                    showTransmission("DEFENSE TOWER DEPLOYED.");
                } else if (STATE.selectedBuilding === 'factory') {
                    createFactory(ghostTower.position.x, ghostTower.position.z);
                    showTransmission("CARBON FACTORY DEPLOYED.");
                }

                playExplosionSound();
            } else {
                showTransmission("INSUFFICIENT CARBON. NEED 10.");
            }
        }

        function updateUI() {
            if (STATE.buildMode) {
                const basicCard = document.getElementById('card-basic-tower');
                const factoryCard = document.getElementById('card-factory');

                // Affordability
                if (STATE.carbon < 10) {
                    basicCard.classList.add('disabled');
                    factoryCard.classList.add('disabled');
                } else {
                    basicCard.classList.remove('disabled');
                    factoryCard.classList.remove('disabled');
                }

                // Selection
                basicCard.classList.remove('selected');
                factoryCard.classList.remove('selected');

                if (STATE.selectedBuilding === 'basic') basicCard.classList.add('selected');
                if (STATE.selectedBuilding === 'factory') factoryCard.classList.add('selected');
            }
        }

        // --- GAME LOGIC ---

        function shoot() {
            const now = Date.now();
            // if (STATE.buildMode) return; // Shooting allowed in build mode now

            if (now - STATE.lastShotTime < 200) return; // Fire rate limit
            STATE.lastShotTime = now;

            const geo = new THREE.BoxGeometry(0.3, 0.3, 1);
            const mat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.projectile });
            const bullet = new THREE.Mesh(geo, mat);

            bullet.position.copy(planeGroup.position);
            bullet.rotation.copy(planeGroup.rotation);

            // Calculate forward vector
            const direction = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), planeGroup.rotation.y);

            scene.add(bullet);
            STATE.projectiles.push({ mesh: bullet, dir: direction, life: 100, isEnemy: false });

            // Play laser sound
            playLaserSound();
        }

        function updateProjectiles() {
            // Check for shoot input
            if (STATE.keys.Enter && !STATE.modalOpen) {
                shoot();
            }

            for (let i = STATE.projectiles.length - 1; i >= 0; i--) {
                const p = STATE.projectiles[i];
                const speed = p.speed || 2; // Default player speed 2
                p.mesh.position.add(p.dir.clone().multiplyScalar(speed));
                p.life--;

                let hit = false;

                // 1. Enemy Projectiles hitting Bases or Factories
                if (p.isEnemy) {
                    const dmg = p.damage || 10;

                    // Check Bases
                    for (let b = 0; b < bases.length; b++) {
                        const base = bases[b];
                        if (p.mesh.position.distanceTo(base.group.position) < base.radius) {
                            damageBase(base, dmg);
                            createExplosion(p.mesh.position, 0xff3333, 0.5);
                            hit = true;
                            break;
                        }
                    }
                    // Check Factories
                    if (!hit) {
                        for (let k = STATE.factories.length - 1; k >= 0; k--) {
                            const f = STATE.factories[k];
                            if (p.mesh.position.distanceTo(f.group.position) < 3) {
                                f.health -= dmg;
                                f.lastDamageTime = Date.now();
                                createExplosion(p.mesh.position, 0xff3333, 0.5);
                                hit = true;

                                if (f.health <= 0) {
                                    createExplosion(f.group.position, 0xffaa00, 3);
                                    scene.remove(f.group);
                                    STATE.factories.splice(k, 1);
                                    playExplosionSound();
                                    showTransmission("FACTORY LOST.");
                                }
                                break;
                            }
                        }
                    }
                }
                // 2. Player Projectiles hitting Asteroids
                else {
                    for (let j = asteroids.length - 1; j >= 0; j--) {
                        const ast = asteroids[j];
                        if (p.mesh.position.distanceTo(ast.mesh.position) < ast.radius + 1) {
                            scene.remove(ast.mesh);
                            asteroids.splice(j, 1);
                            createExplosion(ast.mesh.position, 0xffaa00);

                            // Carbon Drop
                            STATE.carbon += 1;
                            document.getElementById('carbon-val').innerText = STATE.carbon;

                            playExplosionSound();
                            hit = true;
                            break;
                        }
                    }
                }

                if (hit || p.life <= 0) {
                    scene.remove(p.mesh);
                    STATE.projectiles.splice(i, 1);
                }
            }
        }

        function updatePhysics() {
            if (STATE.modalOpen) return;

            // Input Vector
            const input = new THREE.Vector3(0, 0, 0);
            if (STATE.keys.w || STATE.keys.ArrowUp) input.z -= 1;
            if (STATE.keys.s || STATE.keys.ArrowDown) input.z += 1;
            if (STATE.keys.a || STATE.keys.ArrowLeft) input.x -= 1;
            if (STATE.keys.d || STATE.keys.ArrowRight) input.x += 1;

            if (input.length() > 0) input.normalize();

            // Speed & Boost Logic
            let currentMaxSpeed = CONFIG.moveSpeed;
            if (STATE.keys[" "]) currentMaxSpeed = CONFIG.boostSpeed; // Boost

            // Apply Acceleration / Friction
            if (input.length() > 0) {
                STATE.velocity.add(input.multiplyScalar(0.05));
                STATE.velocity.clampLength(0, currentMaxSpeed);

                const angle = Math.atan2(STATE.velocity.x, STATE.velocity.z);
                let rotDiff = angle - planeGroup.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;

                planeGroup.rotation.y += rotDiff * 0.1;
                planeGroup.rotation.z = -rotDiff * 0.5;
            } else {
                STATE.velocity.multiplyScalar(CONFIG.friction);
                planeGroup.rotation.z *= 0.9;
            }

            planeGroup.position.add(STATE.velocity);

            // MAP WRAPPING LOGIC (Teleport)
            if (planeGroup.position.x > CONFIG.mapBounds) planeGroup.position.x = -CONFIG.mapBounds;
            if (planeGroup.position.x < -CONFIG.mapBounds) planeGroup.position.x = CONFIG.mapBounds;
            if (planeGroup.position.z > CONFIG.mapBounds) planeGroup.position.z = -CONFIG.mapBounds;
            if (planeGroup.position.z < -CONFIG.mapBounds) planeGroup.position.z = CONFIG.mapBounds;

            // Camera Follow
            const camOffset = new THREE.Vector3(20, 20, 20);

            // Adjust camera lag for warp effect (snap if distance is huge)
            if (camera.position.distanceTo(planeGroup.position) > 100) {
                camera.position.copy(planeGroup.position).add(camOffset);
            } else {
                const targetPos = planeGroup.position.clone().add(camOffset);
                camera.position.lerp(targetPos, 0.1);
            }
        }

        function checkInteractions() {
            if (STATE.modalOpen) return;
            bases.forEach(base => {
                const dist = planeGroup.position.distanceTo(base.group.position);
                base.group.rotation.y += 0.005;
                base.core.position.y = 2 + Math.sin(Date.now() * 0.002 + base.core.userData.offset) * 0.5;
                if (dist < base.radius) {
                    openModal(base.type);
                    STATE.velocity.set(0, 0, 0);
                }
            });
        }

        function openModal(type) {
            STATE.modalOpen = true;
            document.getElementById(`modal-${type}`).classList.add('active');
        }

        window.closeModal = function () {
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
            setTimeout(() => { STATE.modalOpen = false; }, 200);
            planeGroup.position.x -= Math.sin(planeGroup.rotation.y) * 5;
            planeGroup.position.z -= Math.cos(planeGroup.rotation.y) * 5;
        }

        function createEngineTrail() {
            // Boost Trail or Normal Trail
            if (STATE.velocity.length() < 0.1) return;
            const boost = STATE.keys[" "];
            if (!boost && Math.random() > 0.3) return;

            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const color = boost ? 0xffff00 : 0x00ff00; // Yellow for boost
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
            const p = new THREE.Mesh(geo, mat);

            const offset = new THREE.Vector3(0, 0, 1.5).applyAxisAngle(new THREE.Vector3(0, 1, 0), planeGroup.rotation.y);
            p.position.copy(planeGroup.position).add(offset);

            scene.add(p);
            trailParticles.push({ mesh: p, life: 1.0, type: 'trail' });
        }

        // --- MINI MAP RENDERER ---
        const mapCanvas = document.getElementById('minimap-canvas');
        const mapCtx = mapCanvas.getContext('2d');

        function updateMinimap() {
            if (!STATE.mapVisible) return;

            const w = mapCanvas.width;
            const h = mapCanvas.height;
            const mapScale = w / (CONFIG.mapBounds * 2); // Map units to pixels

            // Clear
            mapCtx.fillStyle = '#001100';
            mapCtx.fillRect(0, 0, w, h);

            // Grid Lines (Visual only)
            mapCtx.strokeStyle = '#003300';
            mapCtx.beginPath();
            mapCtx.moveTo(w / 2, 0); mapCtx.lineTo(w / 2, h);
            mapCtx.moveTo(0, h / 2); mapCtx.lineTo(w, h / 2);
            mapCtx.stroke();

            // Transform helper
            const toMapX = (x) => (x + CONFIG.mapBounds) * mapScale;
            const toMapY = (z) => (z + CONFIG.mapBounds) * mapScale;

            // Draw Asteroids
            mapCtx.fillStyle = '#446644';
            asteroids.forEach(a => {
                mapCtx.beginPath();
                mapCtx.arc(toMapX(a.mesh.position.x), toMapY(a.mesh.position.z), 2, 0, Math.PI * 2);
                mapCtx.fill();
            });

            // Draw Bases
            bases.forEach(b => {
                mapCtx.fillStyle = b.colorString;
                mapCtx.beginPath();
                mapCtx.arc(toMapX(b.group.position.x), toMapY(b.group.position.z), 4, 0, Math.PI * 2);
                mapCtx.fill();
            });

            // Draw Enemies
            mapCtx.fillStyle = '#ff0000';
            STATE.enemies.forEach(e => {
                mapCtx.beginPath();
                mapCtx.arc(toMapX(e.mesh.position.x), toMapY(e.mesh.position.z), 2, 0, Math.PI * 2);
                mapCtx.fill();
            });

            // Draw Player
            mapCtx.fillStyle = '#00ff00';
            mapCtx.beginPath();
            const px = toMapX(planeGroup.position.x);
            const py = toMapY(planeGroup.position.z);

            // Draw simple triangle for player direction
            mapCtx.save();
            mapCtx.translate(px, py);
            mapCtx.rotate(-planeGroup.rotation.y + Math.PI); // Rotate context matches map orientation
            mapCtx.beginPath();
            mapCtx.moveTo(0, -4);
            mapCtx.lineTo(3, 3);
            mapCtx.lineTo(-3, 3);
            mapCtx.closePath();
            mapCtx.fill();
            mapCtx.restore();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (STATE.paused) return;

            if (STATE.gameActive) {
                updatePhysics();
                updateProjectiles();
                updateEnemies();
                updateBases();
                updateTowers();
                updateFactories(); // Update Factories
                updateGameLogic();
                checkInteractions();
                createEngineTrail();
                updateGhost();
                updateUI();
            }

            updateMinimap();

            // Animate Trails & Explosions
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                const p = trailParticles[i];
                p.life -= p.type === 'explosion' ? 0.05 : 0.02;

                if (p.type === 'explosion') {
                    p.mesh.scale.multiplyScalar(1.1); // Expand
                    p.mesh.material.opacity = p.life;
                } else {
                    p.mesh.position.y += 0.05;
                    p.mesh.rotation.x += 0.1;
                    p.mesh.scale.multiplyScalar(0.95);
                    p.mesh.material.opacity = p.life;
                }

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    trailParticles.splice(i, 1);
                }
            }

            asteroids.forEach(a => {
                a.mesh.rotation.y += a.rotSpeed;
                a.mesh.rotation.x += a.rotSpeed;
            });

            // HUD Update
            document.getElementById('coords').innerText = `POS: ${Math.round(planeGroup.position.x)}, ${Math.round(planeGroup.position.z)}`;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            const d = CONFIG.camZoom;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        // Mission Briefing System
        const briefingMessages = [
            "Welcome to Sector ALPHA-9, pilot.",
    "I‚Äôm Commander Augustin.",
    "This station is a tactical command center for GTM and outbound operations.",
    "Navigate to the beacons to access About. Projects. Contact.",
    "Primary objective: Build reliable systems. Protect attention. Create leverage.",
    "Secondary objective: Stay consistent. One session at a time. Like Z2 mileage.",
    "Good luck out there, pilot."
        ];

        function showBriefing() {
            if (STATE.briefingShown) return;
            STATE.briefingShown = true;

            setTimeout(() => {
                const briefing = document.getElementById('mission-briefing');
                briefing.classList.add('active');
                typewriterEffect();
            }, 1000);
        }

        function typewriterEffect() {
            const textElement = document.getElementById('briefing-text');
            const fullText = briefingMessages.join(' ');
            let index = 0;

            // Start Audio
            if (STATE.audioEnabled && AUDIO.typingSound) {
                AUDIO.typingSound.currentTime = 0;
                AUDIO.typingSound.play().catch(e => console.log("Audio play failed:", e));
            }

            textElement.classList.add('typewriter');

            const typeInterval = setInterval(() => {
                if (index < fullText.length) {
                    textElement.textContent = fullText.substring(0, index + 1);
                    textElement.scrollTop = textElement.scrollHeight; // Auto-scroll
                    index++;
                } else {
                    clearInterval(typeInterval);
                    textElement.classList.remove('typewriter');
                    if (AUDIO.typingSound) AUDIO.typingSound.pause();

                    // Auto-close after 15 seconds
                    setTimeout(() => {
                        closeBriefing();
                    }, 15000);
                }
            }, 30);
        }

        function closeBriefing() {
            if (AUDIO.typingSound) AUDIO.typingSound.pause();
            const briefing = document.getElementById('mission-briefing');
            briefing.style.opacity = '0';
            briefing.style.transform = 'translateY(20px)';

            if (briefingCloseTimer) clearTimeout(briefingCloseTimer);
            briefingCloseTimer = setTimeout(() => {
                briefing.classList.remove('active');
                briefing.style.display = 'none';
            }, 500);
        }

        // Listen for space to close briefing early
        window.addEventListener('keydown', (e) => {
            if (e.key === ' ' && document.getElementById('mission-briefing').classList.contains('active')) {
                closeBriefing();
            }
        });

        // Function to start audio on user interaction
        function startAudioOnInteraction() {
            if (!AUDIO.initialized) {
                initAudio();
            } else if (STATE.audioEnabled && AUDIO.bgMusic && AUDIO.bgMusic.paused) {
                AUDIO.bgMusic.play().catch(e => console.log('Audio play failed'));
            }
        }

        // Show briefing on load and initialize audio
        window.addEventListener('load', () => {
            // Mobile Check
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

            if (isMobile) {
                document.getElementById('mobile-warning').style.display = 'flex';
                STATE.gameActive = false; // Stop game logic
            } else {
                // Wait for user interaction via Start Screen
            }
        });

        // Start Game Sequence
        document.getElementById('start-screen').addEventListener('click', () => {
            const screen = document.getElementById('start-screen');
            screen.style.opacity = '0';
            setTimeout(() => screen.style.display = 'none', 500);

            initAudio();
            showBriefing();

            // Ensure UI matches State
            document.getElementById('carbon-val').innerText = STATE.carbon;

            // TEST: Spawn Cargo Ship immediately (Remove this line to disable test)
            // setTimeout(() => {
            //     console.log("Spawning Test Cargo Ship");
            //     spawnEnemy('cargo');
            //     spawnEnemy('cargo');
            //     spawnEnemy('cargo');
            //     spawnEnemy('cargo');
            //     spawnEnemy('cargo');
            // }, 100);
        });

        // Initialize and start audio on first user interaction
        document.addEventListener('click', () => {
            startAudioOnInteraction();
        }, { once: false });  // Changed to false to handle multiple attempts

        document.addEventListener('keydown', () => {
            startAudioOnInteraction();
        }, { once: false });  // Changed to false to handle multiple attempts

        // Also try to start audio when closing the briefing
        window.addEventListener('keydown', (e) => {
            if (e.key === ' ' && document.getElementById('mission-briefing').classList.contains('active')) {
                startAudioOnInteraction();
            }
        });

    </script>
</body>

</html>